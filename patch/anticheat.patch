diff --git a/sql/anticheat/world_anticheat.sql b/sql/anticheat/world_anticheat.sql
new file mode 100644
index 0000000..4dc2128
--- /dev/null
+++ b/sql/anticheat/world_anticheat.sql
@@ -0,0 +1,2 @@
+-- Copyright (C) 2011-2012 BlizzLikeCore <http://blizzlike.servegame.com/>
+INSERT INTO `blizzlike_string` VALUES (6620,'|cfff00000%s is kicked for use teleport to plane. plane_z: %f.|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(6621,'|cfff00000%s produces a anticheat alarm for %s.|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
diff --git a/src/BlizzLikeCore/blizzlikecore.conf.dist b/src/BlizzLikeCore/blizzlikecore.conf.dist
index a732cca..d26e5d9 100644
--- a/src/BlizzLikeCore/blizzlikecore.conf.dist
+++ b/src/BlizzLikeCore/blizzlikecore.conf.dist
@@ -2029,3 +2029,21 @@ DuelMod.Cooldowns = 0
 AutoBroadcast.On = 0
 AutoBroadcast.Center = 0
 AutoBroadcast.Timer = 60000
+
+###############################################################################
+# MOVEMENT ANTICHEAT
+#
+#    Anticheat.Movement.Enable
+#        Enable Movement Anticheat
+#        Default: 1 - (Enabled)
+#                 0 - (Disabled)
+#
+#    Anticheat.Movement.GmLevel
+#        Only accounts that are below this gm-level or exact at the same, are 
+#         reported for cheating.
+#        Default: 0 - (Only normal Players)
+#
+###############################################################################
+
+Anticheat.Movement.Enable = 1
+Anticheat.Movement.GmLevel = 0
diff --git a/src/game/Language.h b/src/game/Language.h
index 2727ac8..40fe0b1 100644
--- a/src/game/Language.h
+++ b/src/game/Language.h
@@ -847,6 +847,8 @@ enum BlizzLikeStrings
     LANG_GM_ANNOUNCE_COLOR               = 6615,
 
     LANG_GM_SILENCE                      = 6616,              // GM Silenced Spell 1852
+    LANG_GM_AC_KICK_ANNOUNCE             = 6620,              // GM AC Kick Announce
+    LANG_GM_AC_ANNOUNCE                  = 6621,              // GM AC Announce
 
     // Use for not-in-offcial-sources patches
     //                                    10000-10999
diff --git a/src/game/MovementHandler.cpp b/src/game/MovementHandler.cpp
index ae3035e..c17787e 100644
--- a/src/game/MovementHandler.cpp
+++ b/src/game/MovementHandler.cpp
@@ -20,6 +20,7 @@
 #include "WorldSession.h"
 #include "Opcodes.h"
 #include "Log.h"
+#include "World.h"
 #include "Corpse.h"
 #include "Player.h"
 #include "MapManager.h"
@@ -27,6 +28,10 @@
 #include "BattleGround.h"
 #include "WaypointMovementGenerator.h"
 #include "InstanceSaveMgr.h"
+#include "Language.h"
+
+//Uncomment to see anti cheat debug messages in console
+//#define MOVEMENT_ANTICHEAT_DEBUG
 
 void WorldSession::HandleMoveWorldportAckOpcode(WorldPacket & /*recv_data*/)
 {
@@ -36,6 +41,7 @@ void WorldSession::HandleMoveWorldportAckOpcode(WorldPacket & /*recv_data*/)
 
 void WorldSession::HandleMoveWorldportAckOpcode()
 {
+    DEBUG_LOG("WORLD: HandleMoveWorldportAckOpcode.");
     // ignore unexpected far teleports
     if (!GetPlayer()->IsBeingTeleportedFar())
         return;
@@ -55,6 +61,9 @@ void WorldSession::HandleMoveWorldportAckOpcode()
         return;
     }
 
+    //reset falltimer at teleport
+    GetPlayer()->m_anti_justteleported = true;
+
     // get the destination map entry, not the current one, this will fix homebind and reset greeting
     MapEntry const* mEntry = sMapStore.LookupEntry(loc.GetMapId());
     InstanceTemplate const* mInstance = objmgr.GetInstanceTemplate(loc.GetMapId());
@@ -201,6 +210,9 @@ void WorldSession::HandleMoveTeleportAck(WorldPacket & recv_data)
     if (guid != plMover->GetGUID())
         return;
 
+    //reset falltimer at teleport
+    plMover->m_anti_justteleported = true;
+
     plMover->SetSemaphoreTeleportNear(false);
 
     uint32 old_zone = plMover->GetZoneId();
@@ -237,6 +249,8 @@ void WorldSession::HandleMoveTeleportAck(WorldPacket & recv_data)
 
 void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
 {
+    uint32 timediff = getMSTime();
+
     Unit *mover = _player->m_mover;
 
     ASSERT(mover != NULL);                                  // there must always be a mover
@@ -246,6 +260,7 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
     // ignore, waiting processing in WorldSession::HandleMoveWorldportAckOpcode and WorldSession::HandleMoveTeleportAck
     if (plMover && plMover->IsBeingTeleported())
     {
+        plMover->m_anti_justteleported = true;
         recv_data.rpos(recv_data.wpos());                   // prevent warnings spam
         return;
     }
@@ -268,6 +283,21 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
     if (!blizzlike::IsValidMapCoord(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation()))
         return;
 
+    bool updateOrientationOnly = false;
+    bool skipAnticheat = false;
+    bool useFallingFlag = false;
+    bool forcemovement = false;
+    bool check_passed = true;
+
+    if (!movementInfo.HasMovementFlag(MOVEFLAG_MOVING) && !mover->HasUnitMovementFlag(MOVEFLAG_MOVING) && !(opcode == MSG_MOVE_FALL_LAND))
+    {
+        #ifdef MOVEMENT_ANTICHEAT_DEBUG
+        sLog.outDetail("Update Orientation Only");
+        #endif
+        skipAnticheat = true;
+        updateOrientationOnly = true;
+    }
+
     //Save movement flags
     mover->SetUnitMovementFlags(movementInfo.GetMovementFlags());
 
@@ -276,73 +306,424 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
     {
         // transports size limited
         // (also received at zeppelin/lift leave by some reason with t_* as absolute in continent coordinates, can be safely skipped)
-        if (movementInfo.GetTransportPos()->GetPositionX() > 50 || movementInfo.GetTransportPos()->GetPositionY() > 50 || movementInfo.GetTransportPos()->GetPositionZ() > 50)
+        if (movementInfo.GetTransportPos()->GetPositionX() > 60 || movementInfo.GetTransportPos()->GetPositionY() > 60 || movementInfo.GetTransportPos()->GetPositionZ() > 60)
             return;
 
         if (!blizzlike::IsValidMapCoord(movementInfo.GetPos()->GetPositionX() + movementInfo.GetTransportPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY() + movementInfo.GetTransportPos()->GetPositionY(),
             movementInfo.GetPos()->GetPositionZ() + movementInfo.GetTransportPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation() + movementInfo.GetTransportPos()->GetOrientation()))
             return;
 
-        // if we boarded a transport, add us to it
-        if (plMover && !plMover->m_transport)
+        if (plMover && plMover->m_anti_transportGUID == 0 && movementInfo.t_guid != 0)
         {
-            // elevators also cause the client to send MOVEFLAG_ONTRANSPORT - just unmount if the guid can be found in the transport list
-            for (MapManager::TransportSet::iterator iter = MapManager::Instance().m_Transports.begin(); iter != MapManager::Instance().m_Transports.end(); ++iter)
+            // if we boarded a transport, add us to it
+            if (!plMover->m_transport)
             {
-                if ((*iter)->GetGUID() == movementInfo.t_guid)
+                float trans_rad = movementInfo.GetTransportPos()->GetPositionX()*movementInfo.GetTransportPos()->GetPositionX() + movementInfo.GetTransportPos()->GetPositionY()*movementInfo.GetTransportPos()->GetPositionY() + movementInfo.GetTransportPos()->GetPositionZ()*movementInfo.GetTransportPos()->GetPositionZ();
+                if (trans_rad > 3600.0f) // transport radius = 60 yards //cheater with on_transport_flag
                 {
-                    // unmount before boarding
-                    plMover->RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
-
-                    plMover->m_transport = (*iter);
-                    (*iter)->AddPassenger(plMover);
-                    break;
+                    return;
+                }
+                // elevators also cause the client to send MOVEFLAG_ONTRANSPORT - just unmount if the guid can be found in the transport list
+                for (MapManager::TransportSet::iterator iter = MapManager::Instance().m_Transports.begin(); iter != MapManager::Instance().m_Transports.end(); ++iter)
+                {
+                    if ((*iter)->GetGUID() == movementInfo.t_guid)
+                    {
+                        // unmount before boarding
+                        plMover->RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
+
+                        plMover->m_transport = (*iter);
+                        (*iter)->AddPassenger(plMover);
+                        break;
+                    }
                 }
             }
+
+            GameObject *obj = HashMapHolder<GameObject>::Find(movementInfo.t_guid);
+            if (obj)
+                plMover->m_anti_transportGUID = obj->GetDBTableGUIDLow();
+            else
+                plMover->m_anti_transportGUID = GUID_LOPART(movementInfo.t_guid);
+
+            #ifdef MOVEMENT_ANTICHEAT_DEBUG
+            sLog.outDetail("On Transport %d", plMover->m_anti_transportGUID ? plMover->m_anti_transportGUID : 0);
+            #endif
         }
     }
     else if (plMover && plMover->m_transport)               // if we were on a transport, leave
     {
+        #ifdef MOVEMENT_ANTICHEAT_DEBUG
+        sLog.outDetail("Left the Transport %d", plMover->m_anti_transportGUID ? plMover->m_anti_transportGUID : 0);
+        #endif
+
         plMover->m_transport->RemovePassenger(plMover);
         plMover->m_transport = NULL;
+        plMover->m_anti_transportGUID = 0;
         movementInfo.ClearTransportData();
     }
-
-    // fall damage generation (ignore in flight case that can be triggered also at lags in moment teleportation to another map).
-    if (opcode == MSG_MOVE_FALL_LAND && plMover && !plMover->isInFlight())
-        plMover->HandleFallDamage(movementInfo);
-
-    if (plMover && (movementInfo.HasMovementFlag(MOVEFLAG_SWIMMING) != plMover->IsInWater()))
+    else if (plMover && plMover->m_anti_transportGUID != 0)
     {
-        // now client not include swimming flag in case jumping under water
-        plMover->SetInWater(!plMover->IsInWater() || plMover->GetBaseMap()->IsUnderWater(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ()));
+        #ifdef MOVEMENT_ANTICHEAT_DEBUG
+        sLog.outDetail("No more Transport %d", plMover->m_anti_transportGUID ? plMover->m_anti_transportGUID : 0);
+        #endif
+        plMover->m_anti_transportGUID = 0;
     }
 
+    if (plMover)
+    {
+        // fall damage generation (ignore in flight case that can be triggered also at lags in moment teleportation to another map).
+        if (opcode == MSG_MOVE_FALL_LAND && !plMover->isInFlight())
+        {
+            if (!World::GetEnableMvAnticheat() || (!plMover->m_anti_ontaxipath && !plMover->m_anti_justteleported && !plMover->m_anti_flymounted))
+                plMover->HandleFallDamage(movementInfo);
+
+            // Fix Blink / Shadowstep
+            if (plMover->m_anti_justteleported)
+                skipAnticheat = true;
+
+            // Fix KnockBack
+            if (plMover->m_anti_isknockedback)
+                forcemovement = true;
+
+            plMover->m_anti_justteleported = false;
+            plMover->m_anti_ontaxipath = false;
+            plMover->m_anti_wasflymounted = false;
+            plMover->m_anti_justjumped = 0;
+            plMover->m_anti_jumpbase = 0;
+            plMover->m_anti_isjumping = false;
+            plMover->m_anti_isknockedback = false;
+        }
+        else if (opcode == MSG_MOVE_START_SWIM)
+            plMover->m_anti_isjumping = false;
+        else if (opcode == MSG_MOVE_JUMP)
+            plMover->m_anti_isjumping = true;
+
+        if (plMover->m_anti_isknockedback)
+            forcemovement = true;
+
+        if (movementInfo.HasMovementFlag(MOVEFLAG_SWIMMING) != plMover->IsInWater())
+        {
+            // now client not include swimming flag in case jumping under water
+            plMover->SetInWater(!plMover->IsInWater() || plMover->GetBaseMap()->IsUnderWater(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ()));
+            plMover->m_anti_justjumped = 0;
+            //if (plMover->GetBaseMap()->IsUnderWater(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ()-7.0f))
+            //    plMover->m_anti_BeginFallZ = INVALID_HEIGHT;
+        }
+        /*----------------------*/
+
+        #ifdef MOVEMENT_ANTICHEAT_DEBUG
+        sLog.outBasic("%s newcoord: tm:%d ftm:%d | %f, %f, %fo(%f) [%X][%s]| transport: %f, %f, %fo(%f)", plMover->GetName(), movementInfo.time, movementInfo.GetFallTime(), movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation(), movementInfo.GetMovementFlags(), LookupOpcodeName(opcode), movementInfo.GetTransportPos()->GetPositionX(), movementInfo.GetTransportPos()->GetPositionY(), movementInfo.GetTransportPos()->GetPositionZ(), movementInfo.GetTransportPos()->GetOrientation());
+        sLog.outBasic("Transport: %d |  tguid: %d - %d", plMover->m_anti_transportGUID, GUID_LOPART(movementInfo.t_guid), GUID_HIPART(movementInfo.t_guid));
+        #endif
+
+        //---- anti-cheat features -->>>
+        if (World::GetEnableMvAnticheat() && GetPlayer()->GetSession()->GetSecurity() <= World::GetMvAnticheatGmLevel() && !plMover->IsInWater() && updateOrientationOnly && plMover->m_anti_transportGUID == 0)
+        {
+            if ((abs(plMover->GetPositionX() - movementInfo.GetPos()->GetPositionX()) > 0.1f) ||
+                (abs(plMover->GetPositionY() - movementInfo.GetPos()->GetPositionY()) > 0.1f) ||
+                (abs(plMover->GetPositionZ() - movementInfo.GetPos()->GetPositionZ()) > 0.1f))
+            {
+                #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                sLog.outDebug("Passiv Movement: dx=%f, dy=%f, dz=%f",
+                    abs(plMover->GetPositionX() - movementInfo.GetPos()->GetPositionX()),
+                    abs(plMover->GetPositionY() - movementInfo.GetPos()->GetPositionY()),
+                    abs(plMover->GetPositionZ() - movementInfo.GetPos()->GetPositionZ()));
+                #endif
+                plMover->m_anti_lastcheat = "Passiv Movement Hack";
+                check_passed = false;
+            }
+        }
+
+        //uint32 curDest = plMover->m_taxi.GetTaxiDestination(); // check taxi flight
+        //if ((plMover->m_anti_transportGUID == 0) && World::GetEnableMvAnticheat() && GetPlayer()->GetSession()->GetSecurity() <= World::GetMvAnticheatGmLevel() && !curDest)
+        if (World::GetEnableMvAnticheat() && GetPlayer()->GetSession()->GetSecurity() <= World::GetMvAnticheatGmLevel() && (plMover->m_anti_transportGUID == 0) && !plMover->m_anti_ontaxipath && !skipAnticheat)
+        {
+            UnitMoveType move_type;
+
+            if (movementInfo.HasMovementFlag(MOVEFLAG_FLYING))
+                move_type = movementInfo.HasMovementFlag(MOVEFLAG_BACKWARD) ? MOVE_FLIGHT_BACK : MOVE_FLIGHT;
+            else if (movementInfo.HasMovementFlag(MOVEFLAG_SWIMMING))
+                move_type = movementInfo.HasMovementFlag(MOVEFLAG_BACKWARD) ? MOVE_SWIM_BACK : MOVE_SWIM;
+            else if (movementInfo.HasMovementFlag(MOVEFLAG_WALK_MODE))
+                move_type = MOVE_WALK;
+            else    //hmm... in first time after login player has MOVE_SWIMBACK instead MOVE_WALKBACK
+                move_type = movementInfo.HasMovementFlag(MOVEFLAG_BACKWARD) ? MOVE_SWIM_BACK : MOVE_RUN;
+
+            float allowed_delta = 0;
+            float current_speed = plMover->GetSpeed(move_type);
+
+            float delta_x = plMover->GetPositionX() - movementInfo.GetPos()->GetPositionX();
+            float delta_y = plMover->GetPositionY() - movementInfo.GetPos()->GetPositionY();
+            float delta_z = plMover->GetPositionZ() - movementInfo.GetPos()->GetPositionZ();
+            float real_delta = delta_x * delta_x + delta_y * delta_y;
+
+            float time_delta = movementInfo.time - plMover->m_anti_lastmovetime;
+            if (time_delta > 0)
+                plMover->m_anti_lastmovetime = movementInfo.time;
+            else
+                time_delta = 0;
+
+            time_delta = (time_delta < 1500) ? time_delta / 1000 : 1.5f; // normalize time - 1.5 second allowed for heavy loaded server
+
+            float tg_z = -99999; // tangens
+            if (!(movementInfo.GetMovementFlags() & (MOVEFLAG_FLYING | MOVEFLAG_SWIMMING)))
+                tg_z = (real_delta != 0) ? (delta_z * delta_z / real_delta) : tg_z;
+
+            if (current_speed < plMover->m_anti_last_hspeed)
+            {
+                allowed_delta = plMover->m_anti_last_hspeed;
+                if (plMover->m_anti_lastspeed_changetime == 0)
+                    plMover->m_anti_lastspeed_changetime = movementInfo.time + (uint32)floor(((plMover->m_anti_last_hspeed / current_speed) * 1000)) + 100; //100ms above for random fluctuating =)))
+            }
+            else
+                allowed_delta = current_speed;
+
+            allowed_delta = allowed_delta * time_delta;
+            allowed_delta = allowed_delta * allowed_delta + 2;
+
+            // Anti-Gravitation
+            float JumpHeight = ((plMover->m_anti_jumpbase > 0) ? plMover->m_anti_jumpbase : 0) - movementInfo.GetPos()->GetPositionZ();
+            if ((plMover->m_anti_jumpbase != 0)
+                        && (plMover->m_anti_justjumped > 0)
+                        && (!plMover->m_anti_justteleported)
+                        && !(movementInfo.HasMovementFlag(MOVEFLAG_SWIMMING) || movementInfo.HasMovementFlag(MOVEFLAG_FLYING)
+                            || movementInfo.HasMovementFlag(MOVEFLAG_FLYING2))
+                        && (JumpHeight < -1.7f)) //max jumpheight is constant for each movementtype
+            {
+                #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                sLog.outDebug("Movement Anticheat: %s is GraviJump exception. anti_jumpbase=%f, anti_justjumped=%u, JumpHeight=%f, last_vspeed=%f",
+                    plMover->GetName(), plMover->m_anti_jumpbase, plMover->m_anti_justjumped, JumpHeight, plMover->m_anti_last_vspeed);
+                #endif
+                plMover->m_anti_lastcheat = "GraviJump Hack";
+                check_passed = false;
+            }
+
+            // Anti-Jumphack
+            if (opcode == MSG_MOVE_JUMP && !plMover->IsInWater())
+            {
+                if (plMover->m_anti_justjumped == 0)
+                {
+                    plMover->m_anti_justjumped += 1;
+                    plMover->m_anti_jumpbase = movementInfo.GetPos()->GetPositionZ();
+                }
+                else
+                {
+                    #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                    sLog.outDebug("Movement Anticheat: %s is Jumphack exception. count=%u",plMover->GetName(), plMover->m_anti_justjumped);
+                    #endif
+                    plMover->m_anti_justjumped = 0;
+                    plMover->m_anti_lastcheat = "Jump Hack";
+                    check_passed = false; //don't process new jump packet
+                }
+            }
+            else if (plMover->IsInWater())
+                plMover->m_anti_justjumped = 0;
+
+            // Anti-Speedhack
+            // Disabled to revert: if ((real_delta > allowed_delta) && (delta_z < (plMover->m_anti_last_vspeed * time_delta) || delta_z < 1))
+            if ((real_delta > allowed_delta) && (delta_z < 1))
+            {
+                #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                sLog.outDebug("Movement Anticheat: %s is speed exception. real_delta=%f, allowed_delta=%f, delta_z=%f, last_vspeed=%f", plMover->GetName(), real_delta, allowed_delta, delta_z, plMover->m_anti_last_vspeed * time_delta);
+                #endif
+                plMover->m_anti_lastcheat = "Speed Hack";
+                check_passed = false;
+            }
+
+            // Anti-Teleport
+            // Disabled to revert: if ((real_delta > allowed_delta) && (real_delta > (time_delta * 100)))
+            if ((real_delta > 4900.0f) && !(real_delta < allowed_delta))
+            {
+                #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                sLog.outDebug("Movement Anticheat: %s is teleport exception. real_delta=%f, allowed_delta=%f, min_delta=%f ", plMover->GetName(), real_delta, allowed_delta, time_delta * 100);
+                #endif
+                plMover->m_anti_lastcheat = "Teleport Hack";
+                check_passed = false;
+            }
+
+            if (movementInfo.time > plMover->m_anti_lastspeed_changetime)
+            {
+                plMover->m_anti_last_hspeed = current_speed; // store current speed
+                plMover->m_anti_last_vspeed = -3.2f; // original value: -2.3f
+                plMover->m_anti_lastspeed_changetime = 0;
+            }
+
+            // Anti-Wallhack
+            // Known issues: jump+up, and walking up with low delta_z (one and only way to make it right is to calculate the delta_z of the terrain)
+            // Disabled to revert: if (!plMover->m_anti_isjumping && (tg_z > 1.6f) && (delta_z < (plMover->m_anti_last_vspeed * time_delta)))
+            if (!plMover->m_anti_isjumping && (tg_z > 1.56f) && (delta_z < plMover->m_anti_last_vspeed))
+            {
+                #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                sLog.outDebug("Movement Anticheat: %s is a wall-climb cheater. tg_z=%f, delta_z=%f, last_vspeed=%f", plMover->GetName(), tg_z, delta_z, plMover->m_anti_last_vspeed * time_delta);
+                #endif
+                plMover->m_anti_lastcheat = "Wall-climbing Hack";
+                check_passed = false;
+            }
+
+            // Anti-Flyhack
+            if (((movementInfo.GetMovementFlags() & (MOVEFLAG_CAN_FLY | MOVEFLAG_FLYING | MOVEFLAG_FLYING2)) != 0) && !(plMover->HasAuraType(SPELL_AURA_FLY) || plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED)))
+            {
+                #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                sLog.outDebug("Movement Anticheat: %s is a fly cheater. {SPELL_AURA_FLY=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_STACKING=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED_STACKING=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED_NOT_STACKING=[%X]}",
+                   plMover->GetName(),
+                   plMover->HasAuraType(SPELL_AURA_FLY), plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED),
+                   plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_STACKING), plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED_STACKING),
+                   plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED_NOT_STACKING));
+                #endif
+                plMover->m_anti_lastcheat = "Fly Hack";
+                useFallingFlag = true;
+                check_passed = false;
+            }
+
+            // Anti-Waterwalk
+            if (movementInfo.HasMovementFlag(MOVEFLAG_WATERWALKING) && !(plMover->HasAuraType(SPELL_AURA_WATER_WALK) | plMover->HasAuraType(SPELL_AURA_GHOST)))
+            {
+                #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                sLog.outDebug("Movement Anticheat: %s is a water-walk cheater. MovementFlags=[%X], SPELL_AURA_WATER_WALK=[%X]", plMover->GetName(), movementInfo.GetMovementFlags(), plMover->HasAuraType(SPELL_AURA_WATER_WALK));
+                #endif
+                plMover->m_anti_lastcheat = "Water Walk Hack";
+                check_passed = false;
+            }
+
     /* process position-change */
-    recv_data.put<uint32>(5, getMSTime());                  // offset flags(4) + unk(1)
-    WorldPacket data(opcode, mover->GetPackGUID().size() + recv_data.size());
-    data << mover->GetPackGUID();
-    data.append(recv_data.contents(), recv_data.size());
-    if (mover->isCharmed() && mover->GetCharmer())
-        mover->GetCharmer()->SendMessageToSet(&data, false);
-    else
-        mover->SendMessageToSet(&data, false);
+            // Anti-Featherfall
+            if (movementInfo.HasMovementFlag(MOVEFLAG_SAFE_FALL) && !(plMover->HasAuraType(SPELL_AURA_FEATHER_FALL)))
+            {
+                #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                sLog.outDebug("Movement Anticheat: %s is a featherfall-fall cheater. MovementFlags=[%X], SPELL_AURA_FEATHER_FALL=[%X]", plMover->GetName(), movementInfo.GetMovementFlags(), plMover->HasAuraType(SPELL_AURA_FEATHER_FALL));
+                #endif
+                plMover->m_anti_lastcheat = "Feather Fall Hack";
+                check_passed = false;
+            }
 
-    mover->m_movementInfo = movementInfo;
-    mover->SetPosition(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation());
+            // Anti-TeleportToPlane
+            if (movementInfo.GetPos()->GetPositionZ() < 0.0001f && movementInfo.GetPos()->GetPositionZ() > -0.0001f && ((movementInfo.GetMovementFlags() & (MOVEFLAG_SWIMMING | MOVEFLAG_CAN_FLY | MOVEFLAG_FLYING | MOVEFLAG_FLYING2)) == 0))
+            {
+                // Prevent using TeleportToPlane.
+                Map *map = plMover->GetMap();
+                if (map)
+                {
+                    float plane_z = map->GetHeight(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), MAX_HEIGHT) - movementInfo.GetPos()->GetPositionZ();
+                    plane_z = (plane_z < -500.0f) ? 0 : plane_z; // check holes in height map
+                    if (plane_z > 0.1f || plane_z < -0.1f)
+                    {
+                        check_passed = false;
+                        #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                        sLog.outDebug("Movement Anticheat: %s uses teleport to plane. plane_z: %f ", plMover->GetName(), plane_z);
+                        #endif
+                        plMover->m_anti_lastcheat = "Teleport to Plane Hack";
+                        plMover->GetSession()->KickPlayer();
+                        sWorld.SendGMText(LANG_GM_AC_KICK_ANNOUNCE, plMover->GetName(), plane_z);
+                    }
+                }
+            }
+        }
+        else if (movementInfo.HasMovementFlag(MOVEFLAG_ONTRANSPORT))
+        {
+            // Anti-Wrap
+            if (plMover->m_transport)
+            {
+                float trans_rad = movementInfo.GetTransportPos()->GetPositionX() * movementInfo.GetTransportPos()->GetPositionX() + movementInfo.GetTransportPos()->GetPositionY() * movementInfo.GetTransportPos()->GetPositionY() + movementInfo.GetTransportPos()->GetPositionZ() * movementInfo.GetTransportPos()->GetPositionZ();
+                if (trans_rad > 3600.0f)
+                    check_passed = false;
+            }
+            else
+            {
+                if (GameObjectData const* go_data = objmgr.GetGOData(plMover->m_anti_transportGUID))
+                {
+                    #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                    sLog.outDebug("Movement Anticheat: %s on some transport. xyz: %f, %f, %f", plMover->GetName(), go_data->posX, go_data->posY, go_data->posZ);
+                    #endif
+
+                    int mapid = go_data->mapid;
+                    if (plMover->GetMapId() != mapid)
+                    {
+                        check_passed = false;
+                    }
+                    else if (mapid != 369)
+                    {
+                        float delta_gox = go_data->posX - movementInfo.GetPos()->GetPositionX();
+                        float delta_goy = go_data->posY - movementInfo.GetPos()->GetPositionY();
+                        float delta_go = delta_gox*delta_gox + delta_goy*delta_goy;
+                        if (delta_go > 3600.0f)
+                            check_passed = false;
+                    }
+                }
+                else
+                {
+                    #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                    sLog.outDebug("Movement Anticheat: %s on undefined transport.", plMover->GetName());
+                    #endif
+                    check_passed = false;
+                }
+            }
+
+            if (!check_passed)
+            {
+                plMover->m_anti_lastcheat = "Transport";
+                if (plMover->m_transport)
+                {
+                    plMover->m_transport->RemovePassenger(plMover);
+                    plMover->m_transport = NULL;
+                }
+                movementInfo.ClearTransportData();
+                plMover->m_anti_transportGUID = 0;
+            }
+        }
+    }
 
     if (plMover)                                            // nothing is charmed, or player charmed
     {
-        if (opcode == MSG_MOVE_FALL_LAND || plMover->m_lastFallTime > movementInfo.GetFallTime() || plMover->m_lastFallZ < movementInfo.GetPos()->GetPositionZ())
-            plMover->SetFallInformation(movementInfo.GetFallTime(), movementInfo.GetPos()->GetPositionZ());
-
-        // we should add the check only for class hunter
-        if (plMover->isMovingOrTurning())
-            plMover->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
+        if (check_passed || GetPlayer()->GetSession()->GetSecurity() > World::GetMvAnticheatGmLevel() || forcemovement)
+        {
+            /* process position-change */
+            recv_data.put<uint32>(5, getMSTime());                  // offset flags(4) + unk(1)
+            WorldPacket data(opcode, mover->GetPackGUID().size() + recv_data.size());
+            data << mover->GetPackGUID();
+            data.append(recv_data.contents(), recv_data.size());
+            mover->SendMessageToSet(&data, false);
+            if (updateOrientationOnly)
+                plMover->SetPosition(plMover->GetPositionX(), plMover->GetPositionY(), plMover->GetPositionZ(), movementInfo.GetPos()->GetOrientation());
+            else
+                plMover->SetPosition(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation());
+
+            plMover->m_movementInfo = movementInfo;
+
+            if (opcode == MSG_MOVE_FALL_LAND || plMover->m_lastFallTime > movementInfo.GetFallTime() || plMover->m_lastFallZ < movementInfo.GetPos()->GetPositionZ())
+                plMover->SetFallInformation(movementInfo.GetFallTime(), movementInfo.GetPos()->GetPositionZ());
+            // we should add the check only for class hunter
+            if (plMover->isMovingOrTurning())
+                plMover->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
+
+            if (movementInfo.GetPos()->GetPositionZ() < -500.0f)
+                plMover->HandleFallUnderMap();
+
+            if (plMover->m_anti_alarmcount > 0 && !plMover->IsInWater())
+            {
+                sWorld.SendGMText(LANG_GM_AC_ANNOUNCE, plMover->GetName(), plMover->m_anti_lastcheat.c_str());
+            }
 
-        if (movementInfo.GetPos()->GetPositionZ() < -500.0f)
-            plMover->HandleFallUnderMap();
+            plMover->m_anti_alarmcount = 0;
+        }
+        else
+        {
+            plMover->m_anti_alarmcount++;
+            WorldPacket data;
+            // Temporary disabled maybee cause fall dmg on dismount in air
+            /* if (useFallingFlag)
+                plMover->SetUnitMovementFlags(MOVEFLAG_FALLING);
+            else
+                plMover->SetUnitMovementFlags(MOVEFLAG_NONE);
+            */
+            plMover->SetUnitMovementFlags(MOVEFLAG_NONE);
+            plMover->BuildTeleportAckMsg(&data, plMover->GetPositionX(), plMover->GetPositionY(), plMover->GetPositionZ(), plMover->GetOrientation());
+            plMover->GetSession()->SendPacket(&data);
+            plMover->BuildHeartBeatMsg(&data);
+            plMover->SendMessageToSet(&data, true);
+        }
     }
+    else
+    if (getMSTimeDiff(timediff, getMSTime()) > 20)
+        sLog.outDebug("Anticheat Process Time: %ums : %s [%x]", getMSTimeDiff(timediff, getMSTime()), LookupOpcodeName(opcode), movementInfo.GetMovementFlags());
 }
 
 void WorldSession::HandleForceSpeedChangeAck(WorldPacket & recv_data)
@@ -366,6 +747,17 @@ void WorldSession::HandleForceSpeedChangeAck(WorldPacket & recv_data)
     // Save movement flags
     GetPlayer()->SetUnitMovementFlags(movementInfo.GetMovementFlags());
 
+    #ifdef MOVEMENT_ANTICHEAT_DEBUG
+    sLog.outBasic("%s CMSG_SPEED_CHANGE_ACK: tm:%d ftm:%d | %f, %f, %fo(%f) [%X]", GetPlayer()->GetName(), movementInfo.time, movementInfo.GetFallTime(), movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation(), movementInfo.GetMovementFlags());
+    sLog.outBasic("%s CMSG_SPEED_CHANGE_ACK additional: vspeed:%f, hspeed:%f, xdir:%f ydir:%f", GetPlayer()->GetName(), movementInfo.j_velocity, movementInfo.j_xyspeed, movementInfo.j_sinAngle, movementInfo.j_cosAngle);
+    #endif
+
+    // skip not personal message;
+    GetPlayer()->m_movementInfo = movementInfo;
+    GetPlayer()->m_anti_last_hspeed = movementInfo.j_xyspeed;
+    GetPlayer()->m_anti_last_vspeed = movementInfo.j_velocity < 3.2f ? movementInfo.j_xyspeed - 1.0f : 3.2f;
+    GetPlayer()->m_anti_lastspeed_changetime = movementInfo.time + 1750;
+
     // client ACK send one packet for mounted/run case and need skip all except last from its
     // in other cases anti-cheat check can be fail in false case
     UnitMoveType move_type;
@@ -397,6 +789,25 @@ void WorldSession::HandleForceSpeedChangeAck(WorldPacket & recv_data)
         if (GetPlayer()->m_forced_speed_changes[force_move_type] > 0)
             return;
     }
+
+/*  Not needed any more, the anticheat handles the speed and the if will never be true
+
+    if (!GetPlayer()->GetTransport() && fabs(GetPlayer()->GetSpeed(move_type) - newspeed) > 0.01f)
+    {
+        if (GetPlayer()->GetSpeed(move_type) > newspeed)         // must be greater - just correct
+        {
+            sLog.outError("%sSpeedChange player %s is NOT correct (must be %f instead %f), force set to correct value",
+                move_type_name[move_type], GetPlayer()->GetName(), GetPlayer()->GetSpeed(move_type), newspeed);
+            GetPlayer()->SetSpeed(move_type, GetPlayer()->GetSpeedRate(move_type), true);
+        }
+        else                                                // must be lesser - cheating
+        {
+            sLog.outBasic("Player %s from account id %u kicked for incorrect speed (must be %f instead %f)",
+                GetPlayer()->GetName(), GetPlayer()->GetSession()->GetAccountId(), GetPlayer()->GetSpeed(move_type), newspeed);
+            GetPlayer()->GetSession()->KickPlayer();
+        }
+    }
+*/
 }
 
 void WorldSession::HandleSetActiveMoverOpcode(WorldPacket & recv_data)
@@ -461,6 +872,19 @@ void WorldSession::HandleMoveKnockBackAck(WorldPacket & recv_data)
 
     // Save movement flags
     GetPlayer()->SetUnitMovementFlags(movementInfo.GetMovementFlags());
+    GetPlayer()->m_anti_isknockedback = true;
+    //Todo: Store the final Position and check it with the Position of MSG_MOVE_FALL_LAND in HandleMovementOpcodes
+
+    #ifdef MOVEMENT_ANTICHEAT_DEBUG
+    sLog.outBasic("%s CMSG_MOVE_KNOCK_BACK_ACK: tm:%d ftm:%d | %f, %f, %fo(%f) [%X]", GetPlayer()->GetName(), movementInfo.time, movementInfo.GetFallTime(), movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation(), movementInfo.GetMovementFlags());
+    sLog.outBasic("%s CMSG_MOVE_KNOCK_BACK_ACK additional: vspeed:%f, hspeed:%f, xdir:%f ydir:%f", GetPlayer()->GetName(), movementInfo.j_velocity, movementInfo.j_xyspeed, movementInfo.j_sinAngle, movementInfo.j_cosAngle);
+    #endif
+
+    // skip not personal message;
+    GetPlayer()->m_movementInfo = movementInfo;
+    GetPlayer()->m_anti_last_hspeed = movementInfo.j_xyspeed;
+    GetPlayer()->m_anti_last_vspeed = movementInfo.j_velocity < 3.2f ? movementInfo.j_xyspeed - 1.0f : 3.2f;
+    GetPlayer()->m_anti_lastspeed_changetime = movementInfo.time + 1750;
 }
 
 void WorldSession::HandleMoveFlyModeChangeAckOpcode(WorldPacket & recv_data)
@@ -476,6 +900,18 @@ void WorldSession::HandleMoveFlyModeChangeAckOpcode(WorldPacket & recv_data)
     recv_data >> movementInfo;
     recv_data.read_skip<uint32>();                          // unk2
 
+    // Movement Anticheat
+    if (movementInfo.HasMovementFlag(MOVEFLAG_FLYING))
+    {
+        GetPlayer()->m_anti_flymounted = true;
+    }
+    else
+    {
+        GetPlayer()->m_anti_flymounted = false;
+        GetPlayer()->m_anti_wasflymounted = true;
+    }
+    //<<< end Movement Anticheat
+
     GetPlayer()->SetUnitMovementFlags(movementInfo.GetMovementFlags());
 }
 
diff --git a/src/game/Player.cpp b/src/game/Player.cpp
index 5c84fc6..fcd3b77 100644
--- a/src/game/Player.cpp
+++ b/src/game/Player.cpp
@@ -382,6 +382,27 @@ Player::Player (WorldSession *session): Unit()
     rest_type=REST_TYPE_NO;
     ////////////////////Rest System/////////////////////
 
+    // Movement Anticheat
+    m_anti_lastmovetime = 0;          //last movement time
+    m_anti_transportGUID = 0;         //current transport GUID
+    m_anti_last_hspeed = 7.0f;        //horizontal speed, default RUN speed
+    m_anti_lastspeed_changetime = 0;  //last speed change time
+    m_anti_last_vspeed = -2.3f;       //vertical speed, default max jump height
+    m_anti_beginfalltime = 0;         //alternative falling begin time
+    m_anti_justteleported = false;    //seted when player was teleported
+    m_anti_alarmcount = 0;            //alarm counter
+    m_anti_flymounted = false;        // seted when player is mounted on flymount
+    m_anti_wasflymounted = false;     // seted when player was mounted on flymount
+    m_anti_ontaxipath = false;        // seted when player is on a taxi fight
+    m_anti_isjumping = false;         // seted when player is in jump phase
+    m_anti_isknockedback = false;     // seted when player is knocked back
+    m_anti_justjumped = 0;            // jump already began, anti-air jump check
+    m_anti_alarmcount = 0;            // alarm counter
+    m_anti_lastcheat.empty();         // stores last cheat as string
+    m_anti_jumpbase = 0;              // Anti-Gravitation
+
+    /////////////////////////////////
+
     m_mailsLoaded = false;
     m_mailsUpdated = false;
     unReadMails = 0;
@@ -20357,12 +20378,16 @@ bool ItemPosCount::isContainedIn(ItemPosCountVec const& vec) const
 
 void Player::HandleFallDamage(MovementInfo& movementInfo)
 {
-    if (movementInfo.GetFallTime() < 1500)
+    // Removed for Anticheat Fall DMG
+    if (!World::GetEnableMvAnticheat() && movementInfo.GetFallTime() < 1500)
         return;
+    else
+        if (movementInfo.GetFallTime() > 400 && movementInfo.GetFallTime() < 1500) // lower falltime then 400 = cheat
+            return;
 
     // calculate total z distance of the fall
     float z_diff = m_lastFallZ - movementInfo.GetPos()->GetPositionZ();
-    DEBUG_LOG("zDiff = %f", z_diff);
+    DEBUG_LOG("zDiff=%f, FallTime=%u", z_diff, movementInfo.GetFallTime());
 
     //Players with low fall distance, Feather Fall or physical immunity (charges used) are ignored
     // 14.57 can be calculated by resolving damageperc formular below to 0
diff --git a/src/game/Player.h b/src/game/Player.h
index 4689f2c..39536cc 100644
--- a/src/game/Player.h
+++ b/src/game/Player.h
@@ -2307,6 +2307,24 @@ class Player : public Unit, public GridObject<Player>
         RestType rest_type;
         ////////////////////Rest System/////////////////////
 
+        // Movement Anticheat
+        uint32 m_anti_lastmovetime;          // last movement time
+        uint64 m_anti_transportGUID;         // current transport GUID
+        float  m_anti_last_hspeed;           // horizontal speed, default RUN speed
+        uint32 m_anti_lastspeed_changetime;  // last speed change time
+        float  m_anti_last_vspeed;           // vertical speed, default max jump height
+        uint32 m_anti_beginfalltime;         // alternative falling begin time
+        bool m_anti_justteleported;          // seted when player was teleported
+        bool m_anti_flymounted;              // seted when player is mounted on flymount
+        bool m_anti_wasflymounted;           // seted when player was mounted on flymount
+        bool m_anti_ontaxipath;              // seted when player is on a taxi fight
+        bool m_anti_isjumping;               // seted when player is in jump phase
+        bool m_anti_isknockedback;           // seted when player is knocked back
+        uint32 m_anti_justjumped;            // jump already began, anti-air jump check
+        uint64 m_anti_alarmcount;            // alarm counter
+        std::string m_anti_lastcheat;        // stores last cheat as string
+        float m_anti_jumpbase;               // Anti-Gravitation
+
         // Transports
         Transport * m_transport;
 
diff --git a/src/game/TaxiHandler.cpp b/src/game/TaxiHandler.cpp
index 0462873..c3ad384 100644
--- a/src/game/TaxiHandler.cpp
+++ b/src/game/TaxiHandler.cpp
@@ -117,6 +117,9 @@ void WorldSession::SendDoFlight(uint16 MountId, uint32 path, uint32 pathNode)
     if (GetPlayer()->hasUnitState(UNIT_STAT_DIED))
         GetPlayer()->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
 
+    // Movement Anticheat
+    GetPlayer()->m_anti_ontaxipath = true;
+
     while (GetPlayer()->GetMotionMaster()->GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE)
         GetPlayer()->GetMotionMaster()->MovementExpired(false);
 
@@ -193,13 +196,32 @@ void WorldSession::HandleTaxiNextDestinationOpcode(WorldPacket & recv_data)
     // 1) end taxi path in far (multi-node) flight
     // 2) switch from one map to other in case multim-map taxi path
     // we need process only (1)
-
     uint32 curDest = GetPlayer()->m_taxi.GetTaxiDestination();
     if (!curDest)
+    {
+        // Movement Anticheat
+        GetPlayer()->Relocate(movementInfo.GetPos());
+        GetPlayer()->m_movementInfo = movementInfo;
+        GetPlayer()->m_anti_lastmovetime = movementInfo.time;
+        GetPlayer()->m_anti_justteleported = true;
+        //<<< end Movement Anticheat
         return;
+    }
 
     TaxiNodesEntry const* curDestNode = sTaxiNodesStore.LookupEntry(curDest);
 
+    if (curDestNode && curDestNode->map_id == GetPlayer()->GetMapId())
+    {
+        while(GetPlayer()->GetMotionMaster()->GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE)
+            GetPlayer()->GetMotionMaster()->MovementExpired(false);
+    }
+
+    //Movement Anticheat
+    GetPlayer()->SetPosition(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation());
+    GetPlayer()->m_movementInfo = movementInfo;
+    GetPlayer()->m_anti_lastmovetime = movementInfo.time;
+    //<<< end Movement Anticheat
+
     // far teleport case
     if (curDestNode && curDestNode->map_id != GetPlayer()->GetMapId())
     {
diff --git a/src/game/World.cpp b/src/game/World.cpp
index c4c3f6f..70623ef 100644
--- a/src/game/World.cpp
+++ b/src/game/World.cpp
@@ -80,6 +80,10 @@ int32 World::m_visibility_notify_periodOnContinents = DEFAULT_VISIBILITY_NOTIFY_
 int32 World::m_visibility_notify_periodInInstances  = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
 int32 World::m_visibility_notify_periodInBGArenas   = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
 
+// Movement Anticheat
+bool World::m_EnableMvAnticheat = true;
+uint32 World::m_MvAnticheatGmLevel = 0;
+
 // World constructor
 World::World()
 {
@@ -531,6 +535,10 @@ void World::LoadConfigSettings(bool reload)
         rate_values[RATE_DURABILITY_LOSS_BLOCK] = 0.0f;
     }
 
+    // Movement Anticheat
+    m_EnableMvAnticheat = sConfig.GetBoolDefault("Anticheat.Movement.Enable", true);
+    m_MvAnticheatGmLevel = sConfig.GetIntDefault("Anticheat.Movement.GmLevel", 0);
+
     // Read other configuration items from the config file
 
     m_configs[CONFIG_COMPRESSION] = sConfig.GetIntDefault("Compression", 1);
diff --git a/src/game/World.h b/src/game/World.h
index a23430a..b28319c 100644
--- a/src/game/World.h
+++ b/src/game/World.h
@@ -574,6 +574,10 @@ class World
         static int32 GetVisibilityNotifyPeriodInInstances() { return m_visibility_notify_periodInInstances;  }
         static int32 GetVisibilityNotifyPeriodInBGArenas()  { return m_visibility_notify_periodInBGArenas;   }
 
+        // Movement Anticheat
+        static bool GetEnableMvAnticheat()              { return m_EnableMvAnticheat;       }
+        static uint32 GetMvAnticheatGmLevel()           { return m_MvAnticheatGmLevel;      }
+
         void ProcessCliCommands();
         void QueueCliCommand(CliCommandHolder* commandHolder) { cliCmdQueue.add(commandHolder); }
 
@@ -661,6 +665,10 @@ class World
         static int32 m_visibility_notify_periodInInstances;
         static int32 m_visibility_notify_periodInBGArenas;
 
+        // Movement Anticheat (Enable Flag)
+        static bool m_EnableMvAnticheat;
+        static uint32 m_MvAnticheatGmLevel;
+
         // CLI command holder to be thread safe
         ACE_Based::LockedQueue<CliCommandHolder*, ACE_Thread_Mutex> cliCmdQueue;
         SqlResultQueue *m_resultQueue;
